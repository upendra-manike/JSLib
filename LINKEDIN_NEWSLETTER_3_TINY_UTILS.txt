ðŸª„ Beyond Lodash: Building Modern, Tree-Shakable Utilities

If you're a JavaScript developer, you've probably used Lodash. It's a fantastic library with over 100 utility functions. But there's a problem: it's heavy. Even importing a single function can pull in more code than you need.

After years of watching bundle sizes grow, I decided to build @upendra.manike/tiny-utils - a modern, tree-shakable alternative that leverages native ES6+ features.

ðŸ“Š The Bundle Size Problem

Let's talk numbers. Lodash is fantastic, but:

â€¢ Full Lodash: ~70KB minified
â€¢ Individual Lodash functions: Still ~24KB for common ones
â€¢ Modern bundlers help, but not all projects use tree-shaking

In a world where every kilobyte matters (especially on mobile), importing a 70KB library for a few utility functions feels wasteful.

ðŸ’¡ The Modern Approach

ES6+ JavaScript introduced powerful native methods that eliminate many Lodash use cases:

â€¢ Array methods: flat(), flatMap(), includes()
â€¢ Object methods: Object.assign(), Object.entries()
â€¢ Set/Map for deduplication
â€¢ Native spread operator

Tiny Utils wraps these modern patterns into clean, consistent APIs while keeping bundle size minimal.

âœ¨ What's Inside

**Array Utilities:**
```typescript
import { chunk, uniq, groupBy, flatten } from '@upendra.manike/tiny-utils';

// Split array into chunks
chunk([1, 2, 3, 4, 5], 2); // [[1, 2], [3, 4], [5]]

// Remove duplicates
uniq([1, 2, 2, 3, 3]); // [1, 2, 3]

// Group by key
groupBy(users, user => user.role);

// Flatten arrays
flatten([1, [2, 3], [4]]); // [1, 2, 3, 4]
```

**Object Utilities:**
```typescript
import { omit, pick, merge, get, set } from '@upendra.manike/tiny-utils';

// Omit keys
omit({ a: 1, b: 2, c: 3 }, ['b']); // { a: 1, c: 3 }

// Pick keys
pick({ a: 1, b: 2, c: 3 }, ['a', 'b']); // { a: 1, b: 2 }

// Deep merge
merge({ a: 1 }, { b: 2 }); // { a: 1, b: 2 }

// Get nested value
get({ user: { name: 'John' } }, 'user.name'); // 'John'
```

**Function Utilities:**
```typescript
import { debounce, throttle, memoize } from '@upendra.manike/tiny-utils';

// Debounce search input
const debouncedSearch = debounce(searchFunction, 300);

// Throttle scroll events
const throttledScroll = throttle(handleScroll, 100);

// Memoize expensive calculations
const expensiveFn = memoize(heavyCalculation);
```

**String Utilities:**
```typescript
import { camelCase, kebabCase, capitalize } from '@upendra.manike/tiny-utils';

camelCase('hello world'); // 'helloWorld'
kebabCase('helloWorld'); // 'hello-world'
capitalize('hello'); // 'Hello'
```

ðŸŽ¯ Key Advantages

1. **Tree-Shakable**
Import only what you use. If you only import `chunk` and `uniq`, that's all that gets bundled.

2. **Zero Dependencies**
No hidden dependencies means predictable bundle sizes.

3. **Modern Patterns**
Built with ES6+ in mind, leveraging native JavaScript features.

4. **TypeScript First**
Full TypeScript support with comprehensive type definitions.

5. **Smaller Bundles**
Typical usage results in 50-70% smaller bundles compared to Lodash equivalents.

ðŸ“¦ Bundle Size Comparison

Let's say you need `chunk`, `uniq`, `omit`, and `debounce`:

â€¢ Lodash: ~24KB (with tree-shaking)
â€¢ Tiny Utils: ~3KB (tree-shaked)

That's an 87% reduction!

ðŸ”§ When to Use What

**Use Tiny Utils when:**
âœ… You need a few utility functions
âœ… Bundle size matters
âœ… You're building modern ES6+ projects
âœ… You want zero dependencies

**Consider Lodash when:**
â€¢ You need many utility functions (50+)
â€¢ You're in a legacy codebase
â€¢ You need specialized functions (e.g., deep clone with circular references)

ðŸ’» Real-World Example

Here's how Tiny Utils can clean up common code patterns:

**Before (without utilities):**
```javascript
// Custom chunk implementation
function chunkArray(array, size) {
  const chunks = [];
  for (let i = 0; i < array.length; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}

// Custom uniq implementation
const unique = [...new Set(array)];

// Custom debounce
let timeout;
function debounced(callback) {
  clearTimeout(timeout);
  timeout = setTimeout(callback, 300);
}
```

**After (with Tiny Utils):**
```typescript
import { chunk, uniq, debounce } from '@upendra.manike/tiny-utils';

const chunks = chunk(array, size);
const unique = uniq(array);
const debounced = debounce(callback, 300);
```

Cleaner, tested, and maintained!

ðŸš€ Getting Started

```bash
npm install @upendra.manike/tiny-utils
```

```typescript
// Import only what you need
import { chunk, uniq, debounce } from '@upendra.manike/tiny-utils';

// Use them
const data = chunk(uniq([1, 2, 2, 3, 3]), 2);
```

The library is MIT licensed and works everywhere modern JavaScript runs.

ðŸŽ“ Best Practices

1. **Import Specifically**: Don't import the entire library
   ```typescript
   // âœ… Good
   import { chunk } from '@upendra.manike/tiny-utils';
   
   // âŒ Avoid
   import * as utils from '@upendra.manike/tiny-utils';
   ```

2. **Use Tree-Shaking**: Ensure your bundler supports it (webpack, rollup, vite all do)

3. **Combine with Native Methods**: Tiny Utils complements native JavaScript, doesn't replace it

4. **Check Performance**: For extremely hot paths, native implementations might be faster

ðŸ”— Check it out: https://www.npmjs.com/package/@upendra.manike/tiny-utils

Open source (MIT). I'd love to hear about your bundle size wins!

What's your biggest bundle size challenge? Are you still using full Lodash, or have you switched to alternatives? Share your experience! ðŸ’¬

#WebDevelopment #JavaScript #TypeScript #Performance #FrontendDevelopment #NPM #OpenSource #BundleSize #Optimization

